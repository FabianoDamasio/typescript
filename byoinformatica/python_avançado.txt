######### List comprehesion #########
y = [valor_a_adiconar condição]


x = [1, 2, 3, 4, 5]
y = [i**2 for i in x] - quadrado dos números
z = [i for i in x if i%2==1] - somente os npumeros ímpares


######### Enumerate #########

lista = ["abacate", "bola", "cachorro"]

for i, none in enumerate(lista) - traz i indice e o valor

######### Filter #########
filtra, filter(função, o que será comparado)

def pares(i):
    if i % 2 == 0:
     return i

lista  = [1, 2, 3, 4, 5]

lista_pares = filter(pares, lista)
print(list(lista_pares))

######### Reduce #########
pega uma lista e retorna um único valor dessa lista

import functools import reduce

def soma(x, y):
    return x+y

lista = [1, 2, 3, 4, 5]

soma = reduce(soma, lista)

######### Map #########
pega a função e aplica a todos os elementos

def dobro(x):
    return x*2

valor = [1, 2, 3, 4, 5]
valor_dobrado = map(dobro, valor)

valor_dobrado = list(valor_dobrado)

######### Lambda #########
utilizar uma função somente uma vez

valor = [1, 2, 3, 4, 5]
valor_dobrado = map(Lambda i: i*2, valor)

valor_dobrado = list(valor_dobrado)


######### Zip #########
compacta duas listas

lista1 = [1, 2, 3, 4, 5]
lista2 = ["abacate", "bola", "cachorro"]

for numero, nome in zip(lista1, lista2):
    print(numero, nome)

######### Modularização #########